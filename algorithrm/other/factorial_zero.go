package other

/**
有关阶乘的两个问题
【题目】
给定一个非负整数N，返回N!结果的末尾为0 的数量。
例如：3!=6，结果的末尾没有0，则返回0。5!=120，结果的末尾有1 个0，返回1。1000000000!，结果的末尾有249999998 个0，返回249999998。

进阶问题：给定一个非负整数N，如果用二进制数表达N!的结果，返回最低位的1 在哪个位置上，认为最右的位置为位置0。
例如：1!=1，最低位的1 在0 位置上。2!=2，最低位的1 在1 位置上。1000000000!，最低位的1 在999999987 位置上。
*/

/*
N!结果的末尾有多少个0 的问题可以转换为1，2，3，…，N-1，N 的序列中一共有多少个因子5。这是因为进行1×2×3×…×N 操作的过程中，
因子2 的数目比因子5 的数目多，所以不管有多少个因子5，都有足够的因子2 与其相乘得到10。所以只要找出1~N 所有的数中一共含有多少个因子5 就可以。
*/
func zeroNum1(num int) int {
	res, cur := 0, 0
	for i := 5; i <= num; i += 5 {
		cur = i
		for cur%5 == 0 {
			res++
			cur /= 5
		}
	}

	return res
}

// 如果把N!的结果中因子5 的总个数记为Z，就可以得到如下关系：Z = N/5 + N/(52) + N/(53) + ... + N/(5i) （i 一直增长，直到5i>N）
func zeroNum2(num int) int {
	if num < 0 {
		return 0
	}

	res := 0
	for num != 0 {
		res += num / 5
		num /= 5
	}

	return res
}

/*
最低位的1 在哪个位置上，完全取决于1~N 的数中因子2 有多少个，因为只要出现一个因子2，最低位的1 就会向左位移一位。
所以，如果把N!的结果中因子2 的总个数记为Z，我们就可以得到如下关系Z = N/2 + N/4 + N/8 + … + N/(2i)（i 一直增长，直到2i>N）
*/
func rightOne1(num int) int {
	if num < 1 {
		return -1
	}

	res := 0
	for num != 0 {
		num >>= 1
		res += num
	}

	return res
}

func rightOne2(num int) int {
	if num < 1 {
		return -1
	}

	ones, tmp := 0, num
	for tmp != 0 {
		if tmp&1 != 0 {
			ones++
		}
		tmp >>= 1
	}

	return num - ones
}
