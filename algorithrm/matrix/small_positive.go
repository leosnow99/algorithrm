package matrix

/**
数组中未出现的最小正整数
【题目】
给定一个无序整型数组arr，找到数组中未出现的最小正整数。
【举例】
arr=[-1,2,3,4]。返回1。
arr=[1,2,3,4]。返回5。
*/

/*
1．在遍历arr 之前先生成两个变量。变量l 表示遍历到目前为止，数组arr 已经包含的正整数范围是[1,l]，所以没有开始遍历之前令l=0，
	表示arr 目前没有包含任何正整数。变量r 表示遍历到目前为止，在后续出现最优状况的情况下，arr 可能包含的正整数范围是[1,r]，
	所以没有开始遍历之前，令r=N，因为还没有开始遍历，所以后续出现的最优状况是arr 包含1~N 所有的整数。r 同时表示arr 当前的结束位置。
2．从左到右遍历arr，遍历到位置l，位置l 的数为arr[l]。
3．如果arr[l]==l+1。没有遍历arr[l]之前，arr 已经包含的正整数范围是[1,l]，此时出现了arr[l]==l+1 的情况，
	所以arr 包含的正整数范围可以扩到[1,l+1]，即令l++。然后重复步骤2。
4．如果arr[l]<=l。没有遍历arr[l]之前，arr 在后续最优的情况下可能包含的正整数范围是[1,r]，已经包含的正整数范围是[1,l]，
	所以需要[l+1,r]上的数。而此时出现了arr[l]<=l，说明[l+1,r]范围上的数少了一个，所以arr 在后续最优的情况下，
	可能包含的正整数范围缩小了，变为[1,r-1]，此时把arr 最后位置的数（arr[r-1]）放在位置l 上，下一步检查这个数，然后令r--。重复步骤2。
5．如果arr[l]>r，与步骤4 同理，把arr 最后位置的数（arr[r-1]）放在位置l 上，下一步检查这个数，然后令r--。重复步骤2。
6．如果arr[arr[l]-1]==arr[l]。如果步骤4 和步骤5 没中，说明arr[l]是在[l+1,r]范围上的数，而且这个数应该放在arr[l]-1 位置上。
	可是此时发现arr[l]-1 位置上的数已经是arr[l]，说明出现了两个arr[l]，既然在[l+1,r]上出现了重复值，那么[l+1,r]范围上的数又少了一个，
	所以与步骤4和步骤5 一样，把arr 最后位置的数（arr[r-1]）放在位置l 上，下一步检查这个数，然后令r--。重复步骤2。
7．如果步骤4、步骤5 和步骤6 都没中，说明发现了[l+1,r]范围上的数，并且此时并未发现重复。那么arr[l]应该放到arr[l]-1 位置上，
	所以把l 位置上的数和arr[l]-1 位置上的数交换，下一步继续遍历l 位置上的数。重复步骤2。
8．最终l 位置和r 位置会碰在一起（l==r），arr 已经包含的正整数范围是[1,l]，返回l+1 即可。
*/
func missNum(arr []int) int {
	l, r := 0, len(arr)
	for l < r {
		if arr[l] == l+1 {
			l++
		} else if arr[l] < l+1 || arr[l] > r || arr[arr[l-1]] == arr[l] {
			r--
			arr[l] = arr[r]
		} else {
			arr[l], arr[arr[l]-1] = arr[arr[l]-1], arr[l]
		}
	}

	return l + 1
}
